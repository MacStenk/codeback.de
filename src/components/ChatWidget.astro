---
// ChatWidget.astro - Briefing Chat f√ºr CodeBack.de
// Vector Search mit Supabase + OpenAI + Email Validation
---

<div id="chat-widget-container"></div>

<script>
  import { createClient } from '@supabase/supabase-js';
  
  // === CONFIG ===
  const OPENAI_API_KEY = import.meta.env.PUBLIC_OPENAI_API_KEY;
  const SUPABASE_URL = import.meta.env.PUBLIC_SUPABASE_URL;
  const SUPABASE_ANON_KEY = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;
  
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  
  // === DEBUG ===
  console.log('üöÄ ChatWidget Script loaded!');
  console.log('üîë ENV Check:', {
    hasOpenAI: !!OPENAI_API_KEY,
    hasSupabase: !!SUPABASE_URL && !!SUPABASE_ANON_KEY
  });
  
  // === SYSTEM PROMPT ===
  const SYSTEM_PROMPT = `Du bist der Briefing-Agent f√ºr CodeBack.de - eine Agentur f√ºr LLM-native Websites f√ºr Coaches & Berater.

DEIN ZIEL: Sammle schnell die wichtigsten Infos und EMAIL!

GESPR√ÑCHSSTIL:
- Ultra-kurz (max 1-2 S√§tze)
- Eine Frage nach der anderen
- Direkt & freundlich

ABLAUF (MAX 6 FRAGEN!):
1. Name
2. Was brauchst du? (Website, Funnel, KI-Tool?)
3. Budget-Range
4. EMAIL (sehr wichtig!)
5. EMAIL BEST√ÑTIGUNG: "üìß Ist [email] korrekt? (ja/nein)"
6. Wann soll's losgehen?

WICHTIG:
- Nach Email-Eingabe IMMER fragen: "üìß Ist [email] korrekt?"
- Bei "ja" ‚Üí Weiter zur n√§chsten Frage
- Bei "nein" ‚Üí "Okay, bitte gib deine Email nochmal ein"
- Nach Email-Best√§tigung ‚Üí Frage nach Timeline
- Bei Budget >‚Ç¨2.500 + best√§tigter Email ‚Üí Qualified Lead
- Nach Timeline ‚Üí Verabschiedung mit: "Perfekt! üéâ Ich hab dir gerade eine Email geschickt. Bitte klick auf den Best√§tigungslink in der Email. Danach bekommst du alle Details und n√§chsten Schritte. Check auch deinen Spam-Ordner! üìß"

START MESSAGE:
"Hi! üëã Ich bin der CodeBack Bot. Wie hei√üt du?"`;

  // === STATE ===
  let messages: Array<{role: string, content: string}> = [];
  let isOpen = false;
  let isLoading = false;
  let leadData: {
    name?: string;
    email?: string;
    emailConfirmed?: boolean;
    business?: string;
    budget?: string;
    timeline?: string;
    isQualified?: boolean;
  } = {};
  
  // === EMAIL VALIDATION ===
  const COMMON_DOMAINS = [
    'gmail.com', 'googlemail.com',
    'yahoo.com', 'yahoo.de',
    'hotmail.com', 'hotmail.de',
    'outlook.com', 'outlook.de',
    'gmx.de', 'gmx.net',
    'web.de', 't-online.de',
    'freenet.de',
    'icloud.com', 'me.com',
    'aol.com', 'live.com'
  ];
  
  const TYPO_MAP: Record<string, string> = {
    // Gmail typos
    'gmial.com': 'gmail.com',
    'gmai.com': 'gmail.com',
    'gmil.com': 'gmail.com',
    'gmaill.com': 'gmail.com',
    'gmmail.com': 'gmail.com',
    'gmal.com': 'gmail.com',
    'gnail.com': 'gmail.com',
    'gamil.com': 'gmail.com',
    // Yahoo typos
    'yahooo.com': 'yahoo.com',
    'yaho.com': 'yahoo.com',
    'yhoo.com': 'yahoo.com',
    // Hotmail typos
    'hotmial.com': 'hotmail.com',
    'hotmail.con': 'hotmail.com',
    'hotmal.com': 'hotmail.com',
    // Outlook typos
    'outlok.com': 'outlook.com',
    'outloo.com': 'outlook.com',
    'outlook.con': 'outlook.com',
    // GMX typos
    'gmx.dd': 'gmx.de',
    'gmx.dee': 'gmx.de',
    // Web.de typos
    'web.dd': 'web.de',
    'web.dee': 'web.de',
    // Freenet typos
    'freent.de': 'freenet.de',
    'frenet.de': 'freenet.de'
  };
  
  function validateEmail(email: string): { valid: boolean; suggestion?: string } {
    // Regex check
    const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      return { valid: false };
    }
    
    // Extract domain
    const domain = email.split('@')[1]?.toLowerCase();
    if (!domain) return { valid: false };
    
    // Check for typos
    if (TYPO_MAP[domain]) {
      return {
        valid: true,
        suggestion: email.split('@')[0] + '@' + TYPO_MAP[domain]
      };
    }
    
    return { valid: true };
  }
  
  // === VECTOR SEARCH ===
  async function searchKnowledge(query: string): Promise<string> {
    try {
      // Create embedding for query
      const embeddingResponse = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: 'text-embedding-3-small',
          input: query
        })
      });
      
      const embeddingData = await embeddingResponse.json();
      const embedding = embeddingData.data[0].embedding;
      
      // Search Supabase
      const { data, error } = await supabase.rpc('match_documents', {
        query_embedding: embedding,
        match_count: 3
      });
      
      if (error) {
        console.error('Vector search error:', error);
        return '';
      }
      
      // Combine results
      return data?.map((d: any) => d.content).join('\n\n') || '';
    } catch (error) {
      console.error('Search knowledge error:', error);
      return '';
    }
  }
  
  // === LEAD TRACKING ===
  function extractLeadInfo(conversation: string): void {
    console.log('üîç extractLeadInfo() called with:', conversation.substring(0, 100) + '...');
    const lower = conversation.toLowerCase();
    
    // Extract Name (after "wie hei√üt du" question)
    if (!leadData.name) {
      const nameMatch = conversation.match(/user: (\w+)/i);
      if (nameMatch) {
        leadData.name = nameMatch[1];
        console.log('üë§ Name extracted:', leadData.name);
      }
    }
    
    // Extract Email
    if (!leadData.email) {
      const emailMatch = conversation.match(/([a-zA-Z0-9.+_-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/i);
      if (emailMatch) {
        const extractedEmail = emailMatch[1].toLowerCase();
        const validation = validateEmail(extractedEmail);
        
        if (validation.valid) {
          leadData.email = validation.suggestion || extractedEmail;
          leadData.emailConfirmed = false;  // Needs confirmation
          console.log('‚úâÔ∏è Email extracted:', leadData.email);
          
          if (validation.suggestion) {
            console.log('üí° Typo detected! Suggested:', validation.suggestion);
          }
        } else {
          console.log('‚ùå Invalid email format:', extractedEmail);
        }
      }
    }
    
    // Check for email confirmation
    if (leadData.email && !leadData.emailConfirmed) {
      const lastUserMessage = messages[messages.length - 2]?.content.toLowerCase() || '';
      if (lastUserMessage.includes('ja') || lastUserMessage.includes('yes') || 
          lastUserMessage.includes('korrekt') || lastUserMessage.includes('stimmt') ||
          lastUserMessage.includes('richtig') || lastUserMessage.includes('‚úÖ')) {
        leadData.emailConfirmed = true;
        console.log('‚úÖ Email confirmed by user');
      } else if (lastUserMessage.includes('nein') || lastUserMessage.includes('no') ||
                 lastUserMessage.includes('falsch') || lastUserMessage.includes('‚ùå')) {
        // User rejected - clear email so they can enter again
        leadData.email = undefined;
        leadData.emailConfirmed = false;
        console.log('‚ùå Email rejected by user, cleared for re-entry');
      }
    }
    
    // Extract Budget - check each user message for numbers
    if (!leadData.budget) {
      // Get all user messages
      const userMessages = messages.filter(m => m.role === 'user').map(m => m.content);
      
      for (const msg of userMessages) {
        // Look for any 4+ digit number (likely a budget)
        const numberMatch = msg.match(/\b(\d{4,})\b/);
        if (numberMatch) {
          const amount = parseInt(numberMatch[1]);
          // Reasonable budget range: 1.000 - 100.000‚Ç¨
          if (amount >= 1000 && amount <= 100000) {
            leadData.budget = `${amount}‚Ç¨`;
            console.log('üí∞ Budget extracted:', leadData.budget, 'from message:', msg);
            break;
          }
        }
        
        // Also check for explicit euro mentions
        const euroMatch = msg.match(/(\d{3,})\s*(?:euro|‚Ç¨|eur)/i);
        if (euroMatch) {
          const amount = parseInt(euroMatch[1].replace(/[^0-9]/g, ''));
          if (amount >= 1000 && amount <= 100000) {
            leadData.budget = `${amount}‚Ç¨`;
            console.log('üí∞ Budget extracted:', leadData.budget, 'from message:', msg);
            break;
          }
        }
      }
    }
    
    // Extract Timeline
    const timelinePatterns = [
      /in (\d+)\s*(woche|monat|tag)/gi,
      /(dringend|schnell|sofort|asap)/gi,
      /bis\s+(\w+)/gi
    ];
    
    timelinePatterns.forEach(pattern => {
      const match = conversation.match(pattern);
      if (match) leadData.timeline = match[0];
    });
    
    // Extract Business
    if (lower.includes('coach') || lower.includes('beratung') || lower.includes('consulting')) {
      leadData.business = 'Coaching/Beratung';
    }
  }
  
  function isLeadQualified(): boolean {
    // Check if budget > ‚Ç¨2500, has name AND email is CONFIRMED
    if (!leadData.budget || !leadData.name || !leadData.email || !leadData.emailConfirmed) {
      console.log('‚ö†Ô∏è Not qualified yet:', {
        ...leadData,
        emailConfirmed: leadData.emailConfirmed || false
      });
      return false;
    }
    
    const amount = parseInt(leadData.budget.replace(/[^0-9]/g, ''));
    const qualified = amount >= 2500;
    console.log(qualified ? '‚úÖ LEAD QUALIFIED!' : '‚ùå Budget too low', leadData);
    return qualified;
  }
  
  async function saveQualifiedLead(): Promise<void> {
    if (!isLeadQualified() || leadData.isQualified) return;
    
    // Set flag IMMEDIATELY to prevent duplicate calls
    leadData.isQualified = true;
    console.log('üîí Lead marked as qualified, preventing duplicate saves');
    
    try {
      // Generate verification token ONCE
      const verificationToken = crypto.randomUUID();
      console.log('üé´ Generated verification token:', verificationToken);
      
      const leadRecord = {
        name: leadData.name,
        email: leadData.email,
        business: leadData.business || 'Nicht angegeben',
        budget: leadData.budget,
        timeline: leadData.timeline || 'Nicht angegeben',
        conversation: messages.map(m => `${m.role}: ${m.content}`).join('\n'),
        email_verified: false,
        verification_token: verificationToken,
        created_at: new Date().toISOString()
      };
      
      console.log('üöÄ Saving unverified lead to Supabase with token:', verificationToken);
      
      const { error } = await supabase
        .from('qualified_leads')
        .insert(leadRecord);
      
      if (error) {
        console.error('‚ùå Supabase insert error:', error);
        // CRITICAL: Reset flag so we can retry saving!
        leadData.isQualified = false;
        return; // Stop here if save failed
      }
      
      // Success!
      console.log('‚úÖ ‚úÖ ‚úÖ QUALIFIED LEAD SAVED (UNVERIFIED)!', leadData);
      
      // Send Verification Email (NOT Magic Link yet!)
      console.log('üìß Sending verification email...');
      console.log('üé´ Email will use token:', verificationToken);
      try {
        // Smart URL detection: Use production URL when deployed, localhost when local
        const siteUrl = window.location.hostname === 'localhost' 
          ? window.location.origin 
          : 'https://codeback.de';
        
        console.log('üåê Using siteUrl:', siteUrl);
        
        const emailResponse = await fetch('/api/send-verification', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: leadData.name,
            email: leadData.email,
            verificationToken: verificationToken,
            siteUrl: siteUrl
          })
        });
        
        if (emailResponse.ok) {
          console.log('‚úÖ Verification email sent successfully!');
        } else {
          const errorData = await emailResponse.json();
          console.error('‚ùå Failed to send verification email:', errorData);
          console.error('‚ùå Response status:', emailResponse.status);
          console.error('‚ùå Response statusText:', emailResponse.statusText);
        }
      } catch (emailError) {
        console.error('‚ùå Email sending error:', emailError);
      }
    } catch (error) {
      console.error('Save lead error:', error);
    }
  }
  
  // === CHAT ===
  async function sendMessage(userMessage: string): Promise<string> {
    // Add to history
    messages.push({ role: 'user', content: userMessage });
    
    // Check if message contains email and has typo
    const emailMatch = userMessage.match(/([a-zA-Z0-9.+_-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/i);
    let typoSystemMessage = null;
    
    if (emailMatch) {
      const email = emailMatch[1].toLowerCase();
      const validation = validateEmail(email);
      
      if (validation.suggestion) {
        typoSystemMessage = {
          role: 'system',
          content: `WICHTIG: User hat gerade eine Email mit Typo eingegeben (${email}). Die korrekte Email ist wahrscheinlich: ${validation.suggestion}. Frage den User: "Meintest du ${validation.suggestion}? (ja/nein)"`
        };
        console.log('üí° Typo detected, informing bot:', validation.suggestion);
      }
    }
    
    // Search knowledge base
    const context = await searchKnowledge(userMessage);
    
    // Build messages with context
    const chatMessages = [
      { role: 'system', content: SYSTEM_PROMPT },
      ...(context ? [{ role: 'system', content: `Kontext aus Knowledge Base:\n${context}` }] : []),
      ...(typoSystemMessage ? [typoSystemMessage] : []),
      ...messages
    ];
    
    // Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: chatMessages,
        temperature: 0.7,
        max_tokens: 300
      })
    });
    
    const data = await response.json();
    const assistantMessage = data.choices[0].message.content;
    
    // Add to history
    messages.push({ role: 'assistant', content: assistantMessage });
    
    // Extract lead info & check qualification
    const conversationText = messages.map(m => `${m.role}: ${m.content}`).join('\n');
    extractLeadInfo(conversationText);
    
    // Save if qualified
    if (isLeadQualified()) {
      await saveQualifiedLead();
    }
    
    return assistantMessage;
  }
  
  // === UI ===
  function createUI() {
    const container = document.getElementById('chat-widget-container');
    if (!container) return;
    
    // Chat Button
    const button = document.createElement('button');
    button.id = 'chat-button';
    button.innerHTML = 'üí¨';
    button.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: #16a34a;
      color: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      transition: transform 0.2s;
    `;
    button.onmouseover = () => button.style.transform = 'scale(1.1)';
    button.onmouseout = () => button.style.transform = 'scale(1)';
    
    // Chat Window
    const chat = document.createElement('div');
    chat.id = 'chat-window';
    chat.style.cssText = `
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: 400px;
      height: 600px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      display: none;
      flex-direction: column;
      z-index: 999;
    `;
    
    chat.innerHTML = `
      <div style="padding: 20px; background: #16a34a; color: white; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0; font-size: 18px;">CodeBack Briefing</h3>
        <button id="close-chat" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">√ó</button>
      </div>
      <div id="messages" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 12px;"></div>
      <div style="padding: 20px; border-top: 1px solid #e5e7eb;">
        <div style="display: flex; gap: 8px;">
          <input id="message-input" type="text" placeholder="Schreib eine Nachricht..." style="flex: 1; padding: 12px; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px;" />
          <button id="send-button" style="padding: 12px 20px; background: #16a34a; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Senden</button>
        </div>
      </div>
    `;
    
    container.appendChild(button);
    container.appendChild(chat);
    
    // Event Listeners
    button.onclick = () => {
      isOpen = !isOpen;
      chat.style.display = isOpen ? 'flex' : 'none';
      if (isOpen && messages.length === 0) {
        const startMsg = SYSTEM_PROMPT.split('START MESSAGE:\n')[1].replace(/"/g, '');
        addBotMessage(startMsg);
      }
    };
    
    document.getElementById('close-chat')!.onclick = () => {
      isOpen = false;
      chat.style.display = 'none';
    };
    
    const input = document.getElementById('message-input') as HTMLInputElement;
    const sendBtn = document.getElementById('send-button')!;
    
    const handleSend = async () => {
      const text = input.value.trim();
      if (!text || isLoading) return;
      
      addUserMessage(text);
      input.value = '';
      isLoading = true;
      sendBtn.textContent = '...';
      sendBtn.disabled = true;
      
      try {
        const response = await sendMessage(text);
        addBotMessage(response);
      } catch (error) {
        console.error('Chat error:', error);
        addBotMessage('Entschuldigung, es gab einen Fehler. Bitte versuche es nochmal.');
      } finally {
        isLoading = false;
        sendBtn.textContent = 'Senden';
        sendBtn.disabled = false;
      }
    };
    
    sendBtn.onclick = handleSend;
    input.onkeypress = (e) => {
      if (e.key === 'Enter' && !isLoading) handleSend();
    };
  }
  
  function addUserMessage(text: string) {
    const messagesDiv = document.getElementById('messages')!;
    const msg = document.createElement('div');
    msg.style.cssText = 'align-self: flex-end; background: #16a34a; color: white; padding: 12px 16px; border-radius: 12px 12px 0 12px; max-width: 70%; word-wrap: break-word;';
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  function addBotMessage(text: string) {
    const messagesDiv = document.getElementById('messages')!;
    const msg = document.createElement('div');
    msg.style.cssText = 'align-self: flex-start; background: #f3f4f6; color: #1f2937; padding: 12px 16px; border-radius: 12px 12px 12px 0; max-width: 70%; word-wrap: break-word;';
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  // Init on page load
  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', createUI);
  }
</script>

<style>
  #chat-widget-container {
    font-family: system-ui, -apple-system, sans-serif;
  }
  
  #messages::-webkit-scrollbar {
    width: 6px;
  }
  
  #messages::-webkit-scrollbar-track {
    background: #f1f1f1;
  }
  
  #messages::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 3px;
  }
  
  #messages::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
</style>

